-- ===========================================
-- DASHBOARD FINANCEIRA – MULTI-TENANT SCHEMA
-- Script completo para criar todas as tabelas necessárias no Supabase
-- ===========================================

-- ===========================================
-- 1. CRIAÇÃO DOS TIPOS ENUM
-- ===========================================

CREATE TYPE tipo_conta AS ENUM ('pix', 'poupanca', 'debito', 'dinheiro', 'credito', 'investimento');

-- ===========================================
-- 2. CRIAÇÃO DAS TABELAS
-- ===========================================

-- Tabela de usuários (identidade dos usuários da aplicação)
CREATE TABLE public.usuarios (
  id         BIGSERIAL PRIMARY KEY,
  nome       TEXT NOT NULL,
  whatsapp   TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Tabela de categorias (por usuário)
CREATE TABLE public.categorias (
  id         BIGSERIAL PRIMARY KEY,
  nome       TEXT NOT NULL,
  tipo       TEXT CHECK (tipo IN ('entrada','saida')) NULL,
  descricao  TEXT NULL,
  cor_hex    TEXT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user_id    UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Tabela de contas financeiras (por usuário)
CREATE TABLE public.contas_financeiras (
  id bigserial NOT NULL,
  nome_conta TEXT NOT NULL,
  tipo_conta tipo_conta NOT NULL,
  saldo NUMERIC(12,2) NOT NULL DEFAULT 0,
  dados_especificos JSONB, -- Informações específicas por tipo (chave PIX, dados bancários, etc.)
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  CONSTRAINT contas_financeiras_pkey PRIMARY KEY (id)
);

-- Tabela de entradas financeiras (por usuário)
CREATE TABLE public.entradas (
  id                   BIGSERIAL PRIMARY KEY,
  data                 DATE NOT NULL,
  valor                NUMERIC(12,2) NOT NULL CHECK (valor >= 0),
  descricao            TEXT NULL,
  categoria_id         BIGINT NULL REFERENCES public.categorias(id) ON DELETE SET NULL,
  whatsapp             TEXT NULL, -- opcional
  created_at           TIMESTAMPTZ NOT NULL DEFAULT now(),
  conta_financeira_id  BIGINT REFERENCES public.contas_financeiras(id) ON DELETE SET NULL,
  user_id              UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Tabela de saídas financeiras (por usuário)
CREATE TABLE public.saidas (
  id                   BIGSERIAL PRIMARY KEY,
  data                 DATE NOT NULL,
  valor                NUMERIC(12,2) NOT NULL CHECK (valor >= 0),
  descricao            TEXT NULL,
  categoria_id         BIGINT NULL REFERENCES public.categorias(id) ON DELETE SET NULL,
  whatsapp             TEXT NULL, -- opcional
  created_at           TIMESTAMPTZ NOT NULL DEFAULT now(),
  conta_financeira_id  BIGINT REFERENCES public.contas_financeiras(id) ON DELETE SET NULL,
  user_id              UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Tabela de contas (a pagar e a receber) (por usuário)
CREATE TABLE public.contas (
  id                       BIGSERIAL PRIMARY KEY,
  descricao                TEXT NOT NULL,
  valor                    NUMERIC(12,2) NOT NULL CHECK (valor >= 0),
  data_vencimento          DATE NOT NULL,
  tipo                     TEXT NOT NULL CHECK (tipo IN ('a_pagar', 'a_receber')),
  status                   TEXT NOT NULL DEFAULT 'pendente' CHECK (status IN ('pendente', 'paga', 'recebida', 'vencida')),
  categoria_id             BIGINT REFERENCES public.categorias(id) ON DELETE SET NULL,
  data_pagamento_recebimento DATE NULL,
  created_at               TIMESTAMPTZ NOT NULL DEFAULT now(),
  whatsapp                 TEXT NULL, -- opcional
  grupo_parcelamento_id    TEXT NULL,
  user_id                  UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Tabela de tarefas (por usuário)
CREATE TABLE IF NOT EXISTS public.tarefas (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  titulo      TEXT NULL,
  descricao   TEXT NULL,
  concluida   BOOLEAN NOT NULL DEFAULT false,
  user_id     UUID REFERENCES auth.users(id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- Tabela de conversas do WhatsApp (por usuário)
CREATE TABLE public.whatsapp_conversas (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  message     JSONB,
  session_id  TEXT,
  user_id     UUID REFERENCES auth.users(id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- ===========================================
-- 3. CRIAÇÃO DOS ÍNDICES
-- ===========================================

-- Índices para tabelas principais
CREATE INDEX entradas_data_idx    ON public.entradas (data);
CREATE INDEX saidas_data_idx      ON public.saidas (data);
CREATE INDEX entradas_cat_idx     ON public.entradas (categoria_id);
CREATE INDEX saidas_cat_idx       ON public.saidas (categoria_id);
CREATE INDEX contas_tipo_idx      ON public.contas (tipo);
CREATE INDEX contas_status_idx    ON public.contas (status);
CREATE INDEX contas_data_vencimento_idx ON public.contas (data_vencimento);
CREATE INDEX contas_categoria_idx ON public.contas (categoria_id);

-- Índices para filtragem por usuário (multi-tenant)
CREATE INDEX categorias_user_id_idx             ON public.categorias(user_id);
CREATE INDEX entradas_user_id_idx               ON public.entradas(user_id);
CREATE INDEX saidas_user_id_idx                 ON public.saidas(user_id);
CREATE INDEX contas_user_id_idx                 ON public.contas(user_id);
CREATE INDEX contas_financeiras_user_id_idx     ON public.contas_financeiras(user_id);
CREATE INDEX tarefas_user_id_idx                ON public.tarefas(user_id);
CREATE INDEX whatsapp_conversas_user_id_idx     ON public.whatsapp_conversas(user_id);

-- Índices úteis para filtros e ordenação
CREATE INDEX IF NOT EXISTS idx_tarefas_concluida  ON public.tarefas (concluida);
CREATE INDEX IF NOT EXISTS idx_tarefas_created_at ON public.tarefas (created_at DESC);

-- ===========================================
-- 4. CRIAÇÃO DAS VIEWS
-- ===========================================

-- 1) Barras: Entradas vs Saídas por mês (filtrando por user_id)
CREATE OR REPLACE VIEW public.vw_entradas_saidas_mensal AS
WITH e AS (
  SELECT date_trunc('month', data) AS mes, SUM(valor) AS total_entradas
  FROM public.entradas
  WHERE user_id = auth.uid()
  GROUP BY 1
),
s AS (
  SELECT date_trunc('month', data) AS mes, SUM(valor) AS total_saidas
  FROM public.saidas
  WHERE user_id = auth.uid()
  GROUP BY 1
)
SELECT
  COALESCE(e.mes, s.mes) AS mes,
  COALESCE(e.total_entradas, 0) AS total_entradas,
  COALESCE(s.total_saidas, 0)   AS total_saidas
FROM e
FULL OUTER JOIN s ON e.mes = s.mes
ORDER BY mes;

-- 2) Donut: Distribuição das Saídas por Categoria (filtrando por user_id)
CREATE OR REPLACE VIEW public.vw_saidas_por_categoria AS
SELECT
  c.id AS categoria_id,
  COALESCE(c.nome, 'Sem categoria') AS categoria,
  SUM(s.valor) AS total_saidas
FROM public.saidas s
LEFT JOIN public.categorias c
  ON c.id = s.categoria_id
 AND c.user_id = auth.uid()
WHERE s.user_id = auth.uid()
GROUP BY c.id, c.nome
ORDER BY total_saidas DESC;

-- 3) Linha: Evolução do Saldo (acumulado) (filtrando por user_id)
CREATE OR REPLACE VIEW public.vw_saldo_diario AS
WITH dias AS (
  SELECT GENERATE_SERIES(
    LEAST(
      COALESCE((SELECT MIN(data) FROM public.entradas WHERE user_id = auth.uid()), CURRENT_DATE),
      COALESCE((SELECT MIN(data) FROM public.saidas   WHERE user_id = auth.uid()), CURRENT_DATE)
    ),
    GREATEST(
      COALESCE((SELECT MAX(data) FROM public.entradas WHERE user_id = auth.uid()), CURRENT_DATE),
      COALESCE((SELECT MAX(data) FROM public.saidas   WHERE user_id = auth.uid()), CURRENT_DATE)
    ),
    INTERVAL '1 day'
  )::date AS dia
),
e AS (
  SELECT data AS dia, SUM(valor) AS entradas_dia
  FROM public.entradas
  WHERE user_id = auth.uid()
  GROUP BY 1
),
s AS (
  SELECT data AS dia, SUM(valor) AS saidas_dia
  FROM public.saidas
  WHERE user_id = auth.uid()
  GROUP BY 1
),
base AS (
  SELECT
    d.dia,
    COALESCE(e.entradas_dia, 0) AS entradas_dia,
    COALESCE(s.saidas_dia,  0) AS saidas_dia,
    COALESCE(e.entradas_dia, 0) - COALESCE(s.saidas_dia, 0) AS saldo_dia
  FROM dias d
  LEFT JOIN e ON e.dia = d.dia
  LEFT JOIN s ON s.dia = d.dia
)
SELECT
  dia,
  entradas_dia,
  saidas_dia,
  SUM(saldo_dia) OVER (ORDER BY dia) AS saldo_acumulado
FROM base
ORDER BY dia;

-- View: Contas por vencer (próximos 30 dias) (filtrando por user_id)
CREATE OR REPLACE VIEW public.vw_contas_vencer AS
SELECT
  id,
  descricao,
  valor,
  data_vencimento,
  tipo,
  status,
  categoria_id,
  whatsapp,
  created_at,
  grupo_parcelamento_id
FROM public.contas
WHERE data_vencimento BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days'
  AND status = 'pendente'
  AND user_id = auth.uid()
ORDER BY data_vencimento;

-- View: Contas vencidas (filtrando por user_id)
CREATE OR REPLACE VIEW public.vw_contas_vencidas AS
SELECT
  id,
  descricao,
  valor,
  data_vencimento,
  tipo,
  status,
  categoria_id,
  whatsapp,
  created_at,
  grupo_parcelamento_id
FROM public.contas
WHERE data_vencimento < CURRENT_DATE
  AND status = 'pendente'
  AND user_id = auth.uid()
ORDER BY data_vencimento;

-- ===========================================
-- 5. CRIAÇÃO DE FUNÇÕES E TRIGGERS
-- ===========================================

-- Função para atualizar automaticamente o status com base na data de vencimento
CREATE OR REPLACE FUNCTION public.atualizar_status_contas()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.data_vencimento < CURRENT_DATE AND NEW.status = 'pendente' THEN
    NEW.status := 'vencida';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para atualizar o status automaticamente ao inserir ou atualizar
CREATE TRIGGER trigger_atualizar_status_contas
  BEFORE INSERT OR UPDATE ON public.contas
  FOR EACH ROW
  EXECUTE FUNCTION public.atualizar_status_contas();

-- Função para automaticamente definir o user_id para novos registros
CREATE OR REPLACE FUNCTION public.set_user_id()
RETURNS TRIGGER AS $$
BEGIN
  NEW.user_id := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers para automaticamente definir o user_id ao inserir registros
CREATE TRIGGER trigger_set_user_id_categorias
  BEFORE INSERT ON public.categorias
  FOR EACH ROW
  EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER trigger_set_user_id_entradas
  BEFORE INSERT ON public.entradas
  FOR EACH ROW
  EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER trigger_set_user_id_saidas
  BEFORE INSERT ON public.saidas
  FOR EACH ROW
  EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER trigger_set_user_id_contas
  BEFORE INSERT ON public.contas
  FOR EACH ROW
  EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER trigger_set_user_id_tarefas
  BEFORE INSERT ON public.tarefas
  FOR EACH ROW
  EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER trigger_set_user_id_contas_financeiras
  BEFORE INSERT ON public.contas_financeiras
  FOR EACH ROW
  EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER trigger_set_user_id_whatsapp_conversas
  BEFORE INSERT ON public.whatsapp_conversas
  FOR EACH ROW
  EXECUTE FUNCTION public.set_user_id();

-- ===========================================
-- 6. CONFIGURAÇÃO DE SEGURANÇA (RLS)
-- ===========================================

-- Habilitar Row Level Security em todas as tabelas de dados
ALTER TABLE public.categorias          ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.entradas            ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.saidas              ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.contas              ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tarefas             ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.contas_financeiras  ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.whatsapp_conversas  ENABLE ROW LEVEL SECURITY;

-- Criar políticas RLS - usuários só podem acessar seus próprios dados
CREATE POLICY categorias_user_policy ON public.categorias
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

CREATE POLICY entradas_user_policy ON public.entradas
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

CREATE POLICY saidas_user_policy ON public.saidas
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

CREATE POLICY contas_user_policy ON public.contas
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

CREATE POLICY tarefas_user_policy ON public.tarefas
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

CREATE POLICY contas_financeiras_user_policy ON public.contas_financeiras
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

CREATE POLICY whatsapp_conversas_user_policy ON public.whatsapp_conversas
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- ===========================================
-- 7. PERMISSÕES PARA USUÁRIOS AUTENTICADOS
-- ===========================================

GRANT ALL ON TABLE public.usuarios            TO authenticated;
GRANT ALL ON TABLE public.categorias          TO authenticated;
GRANT ALL ON TABLE public.entradas            TO authenticated;
GRANT ALL ON TABLE public.saidas              TO authenticated;
GRANT ALL ON TABLE public.contas              TO authenticated;
GRANT ALL ON TABLE public.contas_financeiras  TO authenticated;
GRANT ALL ON TABLE public.tarefas             TO authenticated;
GRANT ALL ON TABLE public.whatsapp_conversas  TO authenticated;

-- Garantir que as sequências sejam acessíveis
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO authenticated;

-- ===========================================
-- 8. COMENTÁRIOS PARA DOCUMENTAÇÃO
-- ===========================================

COMMENT ON TABLE public.contas_financeiras IS 'Tabela para armazenar diferentes tipos de contas financeiras (PIX, poupança, débito, dinheiro, crédito, investimento)';
COMMENT ON COLUMN public.contas_financeiras.tipo_conta IS 'Tipo da conta: pix, poupanca, debito, dinheiro, credito ou investimento';
COMMENT ON COLUMN public.contas_financeiras.dados_especificos IS 'JSON com dados específicos por tipo de conta (chave PIX, dados bancários, etc.)';

-- ===========================================
-- FIM DO SCRIPT DE CRIAÇÃO DO ESQUEMA MULTI-TENANT
-- ===========================================
